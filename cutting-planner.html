<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OSB Cutting Planner</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    min-height: 100vh;
    padding: 20px;
  }
  h1 { font-size: 1.4rem; margin-bottom: 4px; color: #fff; }
  h2 { font-size: 1.1rem; margin-bottom: 8px; color: #ccc; }
  .subtitle { color: #888; font-size: 0.85rem; margin-bottom: 20px; }

  .layout {
    display: grid;
    grid-template-columns: 280px 1fr;
    gap: 20px;
    max-width: 1400px;
    margin: 0 auto;
  }

  .controls {
    background: #16213e;
    border-radius: 10px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    height: fit-content;
    position: sticky;
    top: 20px;
  }
  .control-group {
    border-bottom: 1px solid #1a1a3e;
    padding-bottom: 12px;
  }
  .control-group:last-child { border-bottom: none; padding-bottom: 0; }
  .control-group h3 {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #7f8fa6;
    margin-bottom: 8px;
  }
  .field { margin-bottom: 8px; }
  .field label {
    display: block;
    font-size: 0.8rem;
    color: #aaa;
    margin-bottom: 2px;
  }
  .field input, .field select {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid #2a2a4a;
    border-radius: 5px;
    background: #0f0f23;
    color: #fff;
    font-size: 0.9rem;
    outline: none;
    transition: border-color 0.2s;
  }
  .field input:focus, .field select:focus { border-color: #4a6fa5; }
  .field .unit { font-size: 0.75rem; color: #666; }
  .field-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .validation-banner {
    padding: 10px 14px;
    border-radius: 8px;
    font-size: 0.85rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.3s;
  }
  .validation-banner.valid {
    background: #0d3320;
    border: 1px solid #1a6b3c;
    color: #4ade80;
  }
  .validation-banner.invalid {
    background: #3b1218;
    border: 1px solid #7f1d1d;
    color: #f87171;
  }

  .issues-list {
    margin-top: 6px;
    font-weight: 400;
    font-size: 0.78rem;
    color: #f0a0a0;
  }
  .issues-list li { margin-left: 16px; margin-top: 2px; }
  .issues-list li.warning { color: #f59e0b; }
  .issues-list li.info { color: #60a5fa; }

  .solver-info {
    font-size: 0.75rem;
    color: #7f8fa6;
    line-height: 1.5;
    margin-top: 4px;
  }
  .solver-info strong { color: #ccc; }
  .solver-info .orientation-tag {
    display: inline-block;
    font-size: 0.65rem;
    padding: 1px 6px;
    border-radius: 3px;
    font-weight: 600;
    background: #1a1a3e;
    color: #60a5fa;
    border: 1px solid #2a4a7a;
  }

  .canvas-area {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .diagram-section {
    background: #16213e;
    border-radius: 10px;
    padding: 16px;
  }
  .diagram-section h2 {
    font-size: 0.9rem;
    color: #7f8fa6;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 12px;
  }
  canvas {
    width: 100%;
    border-radius: 6px;
    background: #0f0f23;
  }

  .pieces-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.82rem;
  }
  .pieces-table th {
    text-align: left;
    padding: 6px 10px;
    color: #7f8fa6;
    font-weight: 600;
    border-bottom: 1px solid #2a2a4a;
    font-size: 0.75rem;
    text-transform: uppercase;
  }
  .pieces-table td {
    padding: 5px 10px;
    border-bottom: 1px solid #1a1a3e;
  }
  .pieces-table tr.valid-row td:first-child {
    border-left: 3px solid #4ade80;
    padding-left: 7px;
  }
  .pieces-table tr.invalid-row td { color: #f87171; }

  .waste-info {
    margin-top: 10px;
    font-size: 0.8rem;
    color: #888;
  }
  .waste-info span { color: #facc15; font-weight: 600; }

  .plates-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
  }
  .plates-grid .diagram-section { min-width: 0; }
  @media (max-width: 1000px) {
    .plates-grid { grid-template-columns: 1fr; }
  }

  @media (max-width: 800px) {
    .layout { grid-template-columns: 1fr; }
    .controls { position: static; }
  }
</style>
</head>
<body>

<h1>OSB Cutting Planner</h1>
<p class="subtitle">Auto plate layout solver</p>

<div class="layout">
  <div class="controls">
    <div class="control-group">
      <h3>Frame</h3>
      <div class="field-row">
        <div class="field">
          <label>Width <span class="unit">cm</span></label>
          <input id="frameW" type="number" step="0.1" value="252.9">
        </div>
        <div class="field">
          <label>Depth <span class="unit">cm</span></label>
          <input id="frameD" type="number" step="0.1" value="171.3">
        </div>
      </div>
      <div class="field-row">
        <div class="field">
          <label>Joist spacing c/c <span class="unit">cm</span></label>
          <input id="joistSpacing" type="number" step="0.1" value="50">
        </div>
        <div class="field">
          <label>Joist count</label>
          <input id="joistCount" type="number" step="1" value="4" min="0">
        </div>
      </div>
      <div class="field">
        <label>Lumber width <span class="unit">mm</span></label>
        <input id="lumberW" type="number" step="1" value="48">
      </div>
    </div>

    <div class="control-group">
      <h3>Plates</h3>
      <div class="field-row">
        <div class="field">
          <label>Length <span class="unit">cm</span></label>
          <input id="osbL" type="number" step="0.1" value="239.7">
        </div>
        <div class="field">
          <label>Width <span class="unit">cm</span></label>
          <input id="osbW" type="number" step="0.1" value="119.8">
        </div>
      </div>
      <div class="field">
        <label>Plates available</label>
        <input id="plateCount" type="number" step="1" value="2" min="1">
      </div>
    </div>

    <div id="validationBanner" class="validation-banner valid">
      <span id="validationText">Valid layout</span>
    </div>
    <ul id="issuesList" class="issues-list" style="display:none;"></ul>

    <div class="control-group" id="solverInfoGroup" style="display:none;">
      <h3>Solver</h3>
      <div class="solver-info" id="solverInfo"></div>
    </div>
  </div>

  <div class="canvas-area">
    <div class="diagram-section">
      <h2>Frame Layout (top view)</h2>
      <canvas id="frameCanvas" height="350"></canvas>
    </div>

    <div id="platesContainer" class="plates-grid"></div>

    <div class="diagram-section">
      <h2>Pieces</h2>
      <table class="pieces-table">
        <thead>
          <tr><th>Piece</th><th>Dimensions</th><th>Plate</th><th>Position</th><th>Status</th></tr>
        </thead>
        <tbody id="piecesBody"></tbody>
      </table>
      <div id="wasteInfo" class="waste-info"></div>
    </div>
  </div>
</div>

<script>
const PALETTE = [
  '#3b82f6', '#10b981', '#f59e0b', '#6366f1',
  '#ef4444', '#e879f9', '#14b8a6', '#f97316',
  '#8b5cf6', '#06b6d4', '#84cc16', '#ec4899',
];
const COLORS = {
  frame: '#4a5568',
  joist: '#718096',
  waste: '#1f2937',
  invalid: '#ef4444',
  validBorder: '#22c55e',
  cutOnJoist: '#4ade80',
  cutOffJoist: '#f59e0b',
};
const EPS = 0.5;

function getInputs() {
  return {
    frameW: parseFloat(document.getElementById('frameW').value),
    frameD: parseFloat(document.getElementById('frameD').value),
    joistSpacing: parseFloat(document.getElementById('joistSpacing').value),
    joistCount: parseInt(document.getElementById('joistCount').value),
    lumberW: parseFloat(document.getElementById('lumberW').value) / 10,
    osbL: parseFloat(document.getElementById('osbL').value),
    osbW: parseFloat(document.getElementById('osbW').value),
    plateCount: parseInt(document.getElementById('plateCount').value),
  };
}

// ===== GRID GENERATION =====

function nearJoist(pos, joists, lumberW) {
  const half = lumberW / 2;
  for (const j of joists) {
    if (Math.abs(pos - j) <= half) return true;
  }
  return false;
}

/**
 * Generate a grid layout for a given orientation.
 * frameLen: dimension along plate length direction
 * frameSpan: dimension along plate width direction (rows stack this way)
 * plateL, plateW: plate dimensions for this orientation
 * joists: array of joist positions along frameLen
 * lumberW: joist width in cm
 * orientation: label string
 * isRotated: whether plate is rotated from its natural orientation
 */
function generateGrid(frameLen, frameSpan, plateL, plateW, joists, lumberW, orientation, isRotated) {
  const numRows = Math.ceil(frameSpan / plateW);
  const numCols = Math.ceil(frameLen / plateL);

  const pieces = [];
  for (let r = 0; r < numRows; r++) {
    const rowY = r * plateW;
    const rowH = Math.min(plateW, frameSpan - rowY);
    for (let c = 0; c < numCols; c++) {
      const colX = c * plateL;
      const colW = Math.min(plateL, frameLen - colX);
      pieces.push({
        name: `R${r + 1}C${c + 1}`,
        row: r, col: c,
        fx: colX, fy: rowY,
        w: colW, h: rowH,
        color: PALETTE[(r * numCols + c) % PALETTE.length],
        isFullPlate: Math.abs(colW - plateL) < EPS && Math.abs(rowH - plateW) < EPS,
        needsCutW: colW < plateL - EPS,
        needsCutH: rowH < plateW - EPS,
      });
    }
  }

  // Vertical cuts between columns (along frameLen axis)
  const vCuts = [];
  for (let c = 1; c < numCols; c++) {
    const cutPos = c * plateL;
    if (cutPos < frameLen - EPS) {
      vCuts.push({ pos: cutPos, onJoist: nearJoist(cutPos, joists, lumberW) });
    }
  }

  // Horizontal cuts between rows (along frameSpan axis)
  const hCuts = [];
  for (let r = 1; r < numRows; r++) {
    const cutPos = r * plateW;
    if (cutPos < frameSpan - EPS) {
      hCuts.push({ pos: cutPos });
    }
  }

  const joistAligned = vCuts.filter(c => c.onJoist).length;
  const joistTotal = vCuts.length;
  const totalCuts = vCuts.length + hCuts.length;

  return {
    pieces, vCuts, hCuts,
    numRows, numCols,
    totalPlates: pieces.length,
    totalCuts,
    orientation, isRotated,
    plateL, plateW,
    frameLen, frameSpan,
    joistAligned, joistTotal,
  };
}

// ===== PACKING SOLVER =====

/**
 * Generate all rotation variants for a piece.
 * Returns [{w, h, rotated: false}, {w, h, rotated: true}] (deduped if square).
 */
function pieceOrientations(p) {
  const variants = [{ w: p.w, h: p.h, rotated: false }];
  if (Math.abs(p.w - p.h) > EPS) {
    variants.push({ w: p.h, h: p.w, rotated: true });
  }
  return variants;
}

/**
 * Try to pack a set of pieces onto one plate.
 * Returns array of { piece, x, y, pw, ph } or null.
 * pw/ph = actual placed width/height (may be rotated from piece.w/h).
 */
function packOnePlate(pieces, plateL, plateW) {
  if (pieces.length === 0) return null;
  if (pieces.length === 1) return packOne(pieces[0], plateL, plateW);
  if (pieces.length === 2) return packTwo(pieces[0], pieces[1], plateL, plateW);
  if (pieces.length === 3) return packThree(pieces, plateL, plateW);
  if (pieces.length === 4) return packFour(pieces, plateL, plateW);
  return packShelf(pieces, plateL, plateW);
}

function packOne(p, pL, pW) {
  for (const o of pieceOrientations(p)) {
    if (o.w <= pL + EPS && o.h <= pW + EPS)
      return [{ piece: p, x: 0, y: 0, pw: o.w, ph: o.h }];
  }
  return null;
}

function packTwo(a, b, pL, pW) {
  for (const oa of pieceOrientations(a)) {
    for (const ob of pieceOrientations(b)) {
      // Side by side (a left, b right)
      if (oa.w + ob.w <= pL + EPS && Math.max(oa.h, ob.h) <= pW + EPS) {
        return [
          { piece: a, x: 0, y: 0, pw: oa.w, ph: oa.h },
          { piece: b, x: oa.w, y: 0, pw: ob.w, ph: ob.h },
        ];
      }
      // Stacked (a top, b bottom)
      if (Math.max(oa.w, ob.w) <= pL + EPS && oa.h + ob.h <= pW + EPS) {
        return [
          { piece: a, x: 0, y: 0, pw: oa.w, ph: oa.h },
          { piece: b, x: 0, y: oa.h, pw: ob.w, ph: ob.h },
        ];
      }
    }
  }
  return null;
}

function packThree(pieces, pL, pW) {
  // Try all permutations of anchor + rest, with all rotation combos
  for (let i = 0; i < 3; i++) {
    const anchor = pieces[i];
    const rest = pieces.filter((_, idx) => idx !== i);
    for (const oa of pieceOrientations(anchor)) {
      for (const or0 of pieceOrientations(rest[0])) {
        for (const or1 of pieceOrientations(rest[1])) {
          // Anchor left, rest stacked right
          if (oa.h <= pW + EPS) {
            const remL = pL - oa.w;
            if (remL >= -EPS) {
              // r0 top-right, r1 bottom-right (stacked)
              if (Math.max(or0.w, or1.w) <= remL + EPS && or0.h + or1.h <= pW + EPS) {
                return [
                  { piece: anchor, x: 0, y: 0, pw: oa.w, ph: oa.h },
                  { piece: rest[0], x: oa.w, y: 0, pw: or0.w, ph: or0.h },
                  { piece: rest[1], x: oa.w, y: or0.h, pw: or1.w, ph: or1.h },
                ];
              }
              // r0 and r1 side by side right of anchor
              if (or0.w + or1.w <= remL + EPS && Math.max(or0.h, or1.h) <= pW + EPS) {
                return [
                  { piece: anchor, x: 0, y: 0, pw: oa.w, ph: oa.h },
                  { piece: rest[0], x: oa.w, y: 0, pw: or0.w, ph: or0.h },
                  { piece: rest[1], x: oa.w + or0.w, y: 0, pw: or1.w, ph: or1.h },
                ];
              }
            }
          }
          // Anchor top, rest below side by side
          if (oa.w <= pL + EPS) {
            const remH = pW - oa.h;
            if (remH >= -EPS && or0.w + or1.w <= pL + EPS && Math.max(or0.h, or1.h) <= remH + EPS) {
              return [
                { piece: anchor, x: 0, y: 0, pw: oa.w, ph: oa.h },
                { piece: rest[0], x: 0, y: oa.h, pw: or0.w, ph: or0.h },
                { piece: rest[1], x: or0.w, y: oa.h, pw: or1.w, ph: or1.h },
              ];
            }
          }
        }
      }
    }
  }
  return null;
}

function packFour(pieces, pL, pW) {
  // Try 2+2 splits with all rotation combos
  const splits = [
    [[0, 1], [2, 3]], [[0, 2], [1, 3]], [[0, 3], [1, 2]]
  ];
  for (const [g1idx, g2idx] of splits) {
    const g1 = g1idx.map(i => pieces[i]);
    const g2 = g2idx.map(i => pieces[i]);
    for (const o0 of pieceOrientations(g1[0])) {
      for (const o1 of pieceOrientations(g1[1])) {
        for (const o2 of pieceOrientations(g2[0])) {
          for (const o3 of pieceOrientations(g2[1])) {
            const g1w = o0.w + o1.w, g1h = Math.max(o0.h, o1.h);
            const g2w = o2.w + o3.w, g2h = Math.max(o2.h, o3.h);
            // Two rows of pairs
            if (Math.max(g1w, g2w) <= pL + EPS && g1h + g2h <= pW + EPS) {
              return [
                { piece: g1[0], x: 0, y: 0, pw: o0.w, ph: o0.h },
                { piece: g1[1], x: o0.w, y: 0, pw: o1.w, ph: o1.h },
                { piece: g2[0], x: 0, y: g1h, pw: o2.w, ph: o2.h },
                { piece: g2[1], x: o2.w, y: g1h, pw: o3.w, ph: o3.h },
              ];
            }
            // Two columns of pairs
            if (g1h + g2h <= pL + EPS && Math.max(g1w, g2w) <= pW + EPS) {
              // Transpose layout
            }
          }
        }
      }
    }
  }
  // 3+1 splits
  for (let i = 0; i < 4; i++) {
    const single = pieces[i];
    const three = pieces.filter((_, idx) => idx !== i);
    for (const os of pieceOrientations(single)) {
      // Single on top, three below
      if (os.w <= pL + EPS && os.h <= pW + EPS) {
        const r = packThree(three, pL, pW - os.h);
        if (r) {
          return [
            { piece: single, x: 0, y: 0, pw: os.w, ph: os.h },
            ...r.map(item => ({ ...item, y: item.y + os.h })),
          ];
        }
      }
      // Single on left, three to the right
      if (os.w <= pL + EPS && os.h <= pW + EPS) {
        const r = packThree(three, pL - os.w, pW);
        if (r) {
          return [
            { piece: single, x: 0, y: 0, pw: os.w, ph: os.h },
            ...r.map(item => ({ ...item, x: item.x + os.w })),
          ];
        }
      }
    }
  }
  return null;
}

function packShelf(pieces, pL, pW) {
  // Try both normal and rotated for each piece
  const sorted = [...pieces].sort((a, b) => (b.w * b.h) - (a.w * a.h));
  const placed = [];
  let curX = 0, curY = 0, rowH = 0;
  for (const p of sorted) {
    let fit = false;
    for (const o of pieceOrientations(p)) {
      if (curX + o.w <= pL + EPS && curY + o.h <= pW + EPS) {
        placed.push({ piece: p, x: curX, y: curY, pw: o.w, ph: o.h });
        rowH = Math.max(rowH, o.h);
        curX += o.w;
        fit = true;
        break;
      }
      if (o.w <= pL + EPS && curY + rowH + o.h <= pW + EPS) {
        curY += rowH;
        curX = 0; rowH = 0;
        placed.push({ piece: p, x: curX, y: curY, pw: o.w, ph: o.h });
        rowH = Math.max(rowH, o.h);
        curX += o.w;
        fit = true;
        break;
      }
    }
    if (!fit) return null;
  }
  return placed;
}

/**
 * Assign pieces to plates using brute-force for small counts, greedy for large.
 * Returns { plates: [...], totalPlatesUsed, success, feedback }
 */
function assignPlatePacking(pieces, plateL, plateW, maxPlates) {
  const n = pieces.length;

  // For small piece counts (≤6), try brute-force partitioning to find optimal
  if (n <= 6 && maxPlates >= 2) {
    const best = bruteForceAssign(pieces, plateL, plateW, maxPlates);
    if (best) return best;
  }

  // Greedy fallback: sort by area descending, assign to first plate with room
  const sorted = [...pieces].sort((a, b) => (b.w * b.h) - (a.w * a.h));
  const plates = [];

  for (const p of sorted) {
    let placed = false;
    for (const plate of plates) {
      const testPieces = [...plate.pieces, p];
      const layout = packOnePlate(testPieces, plateL, plateW);
      if (layout) {
        plate.pieces = testPieces;
        plate.layout = layout;
        placed = true;
        break;
      }
    }
    if (!placed) {
      if (plates.length >= maxPlates) {
        const needed = estimateMinPlates(pieces, plateL, plateW);
        return {
          plates,
          totalPlatesUsed: plates.length,
          success: false,
          feedback: `Need at least ${needed} plates but only ${maxPlates} available`,
        };
      }
      const layout = packOnePlate([p], plateL, plateW);
      if (!layout) {
        // Piece is too large for the plate in any orientation
        return {
          plates,
          totalPlatesUsed: plates.length,
          success: false,
          feedback: `Piece ${p.name} (${p.w.toFixed(1)}×${p.h.toFixed(1)}) doesn't fit on plate (${plateL}×${plateW})`,
        };
      }
      plates.push({ pieces: [p], layout });
    }
  }

  return { plates, totalPlatesUsed: plates.length, success: true, feedback: null };
}

/**
 * Brute-force partition N pieces into at most maxPlates groups,
 * each fitting on one plate. Returns best assignment or null.
 */
function bruteForceAssign(pieces, plateL, plateW, maxPlates) {
  const n = pieces.length;
  // Assign each piece to a plate index [0, maxPlates-1]
  // Total combos: maxPlates^n (bounded since n ≤ 6, maxPlates ≤ ~10)
  const limit = Math.min(maxPlates, n); // no point using more plates than pieces
  const totalCombos = Math.pow(limit, n);
  if (totalCombos > 100000) return null; // safety limit

  let bestResult = null;
  let bestPlateCount = Infinity;

  const assignment = new Array(n).fill(0);
  for (let combo = 0; combo < totalCombos; combo++) {
    // Decode combo into assignment
    let c = combo;
    for (let i = 0; i < n; i++) {
      assignment[i] = c % limit;
      c = Math.floor(c / limit);
    }

    // Group pieces by plate
    const groups = [];
    let usedPlates = 0;
    for (let i = 0; i < n; i++) {
      while (groups.length <= assignment[i]) groups.push([]);
      groups[assignment[i]].push(pieces[i]);
    }
    usedPlates = groups.filter(g => g.length > 0).length;
    if (usedPlates >= bestPlateCount) continue;

    // Check all groups fit
    let allFit = true;
    const layouts = [];
    for (const group of groups) {
      if (group.length === 0) { layouts.push(null); continue; }
      const layout = packOnePlate(group, plateL, plateW);
      if (!layout) { allFit = false; break; }
      layouts.push(layout);
    }

    if (allFit && usedPlates < bestPlateCount) {
      bestPlateCount = usedPlates;
      const plates = [];
      for (let gi = 0; gi < groups.length; gi++) {
        if (groups[gi].length > 0) {
          plates.push({ pieces: groups[gi], layout: layouts[gi] });
        }
      }
      bestResult = { plates, totalPlatesUsed: usedPlates, success: true, feedback: null };
      if (usedPlates <= 1) break; // can't do better
    }
  }

  return bestResult;
}

function estimateMinPlates(pieces, plateL, plateW) {
  // Try brute-force to find actual minimum
  if (pieces.length <= 6) {
    for (let k = 1; k <= pieces.length; k++) {
      const result = bruteForceAssign(pieces, plateL, plateW, k);
      if (result) return k;
    }
  }
  const plateArea = plateL * plateW;
  const totalArea = pieces.reduce((s, p) => s + p.w * p.h, 0);
  return Math.max(Math.ceil(totalArea / plateArea), 1);
}

/**
 * Generate grid with optimized (non-uniform) column widths.
 * Tries various split points to find piece dimensions that pack well.
 * Returns array of grid candidates (same structure as generateGrid).
 */
function generateOptimizedGrids(frameLen, frameSpan, plateL, plateW, joists, lumberW, orientation, isRotated) {
  const results = [];
  const numRows = Math.ceil(frameSpan / plateW);

  // Helper: check if ALL pieces from given column widths fit on a plate
  function allPiecesFit(colWidths) {
    for (const cw of colWidths) {
      for (let r = 0; r < numRows; r++) {
        const rh = Math.min(plateW, frameSpan - r * plateW);
        const fitsNormal = cw <= plateL + EPS && rh <= plateW + EPS;
        const fitsRotated = rh <= plateL + EPS && cw <= plateW + EPS;
        if (!fitsNormal && !fitsRotated) return false;
      }
    }
    return true;
  }

  // For numCols=1 (no vertical cuts), just one option
  if (frameLen <= plateL + EPS && allPiecesFit([frameLen])) {
    results.push(generateGridWithCols(frameLen, frameSpan, [frameLen], plateW, joists, lumberW, orientation, isRotated, plateL));
  }

  // For numCols=2: try many split positions
  if (frameLen > plateL + EPS || true) { // always try 2 cols
    const splits = new Set();

    // Standard plate-width split
    if (plateL < frameLen) splits.add(Math.round(plateL * 10) / 10);

    // Half split
    splits.add(Math.round(frameLen / 2 * 10) / 10);

    // Split at plateW (short plate dimension) — key for side-by-side packing!
    if (plateW < frameLen) splits.add(Math.round(plateW * 10) / 10);

    // Splits at joist positions
    for (const j of joists) {
      if (j > EPS && j < frameLen - EPS) splits.add(Math.round(j * 10) / 10);
    }

    // Split at plateL - small offsets (to create cuttable pairs)
    const halfPlateL = plateL / 2;
    if (halfPlateL > EPS && halfPlateL < frameLen - EPS) splits.add(Math.round(halfPlateL * 10) / 10);

    for (const splitAt of splits) {
      if (splitAt <= EPS || splitAt >= frameLen - EPS) continue;
      const colWidths = [splitAt, frameLen - splitAt];
      if (!allPiecesFit(colWidths)) continue;
      results.push(generateGridWithCols(frameLen, frameSpan, colWidths, plateW, joists, lumberW, orientation, isRotated, plateL));
    }
  }

  // For numCols=3: try uniform thirds and joist-aligned
  if (frameLen > plateL * 2 + EPS) {
    const third = frameLen / 3;
    const colWidths = [third, third, frameLen - 2 * third];
    if (allPiecesFit(colWidths)) {
      results.push(generateGridWithCols(frameLen, frameSpan, colWidths, plateW, joists, lumberW, orientation, isRotated, plateL));
    }
  }

  return results;
}

/**
 * Generate grid given explicit column widths.
 */
function generateGridWithCols(frameLen, frameSpan, colWidths, plateW, joists, lumberW, orientation, isRotated, plateL) {
  const numRows = Math.ceil(frameSpan / plateW);
  const numCols = colWidths.length;

  const pieces = [];
  let colX = 0;
  for (let c = 0; c < numCols; c++) {
    const colW = colWidths[c];
    for (let r = 0; r < numRows; r++) {
      const rowY = r * plateW;
      const rowH = Math.min(plateW, frameSpan - rowY);
      pieces.push({
        name: `R${r + 1}C${c + 1}`,
        row: r, col: c,
        fx: colX, fy: rowY,
        w: colW, h: rowH,
        color: PALETTE[(r * numCols + c) % PALETTE.length],
        isFullPlate: Math.abs(colW - plateL) < EPS && Math.abs(rowH - plateW) < EPS,
        needsCutW: colW < plateL - EPS,
        needsCutH: rowH < plateW - EPS,
      });
    }
    colX += colW;
  }

  // Vertical cuts between columns
  const vCuts = [];
  let cutX = 0;
  for (let c = 0; c < numCols - 1; c++) {
    cutX += colWidths[c];
    if (cutX < frameLen - EPS) {
      vCuts.push({ pos: cutX, onJoist: nearJoist(cutX, joists, lumberW) });
    }
  }

  // Horizontal cuts between rows
  const hCuts = [];
  for (let r = 1; r < numRows; r++) {
    const cutPos = r * plateW;
    if (cutPos < frameSpan - EPS) {
      hCuts.push({ pos: cutPos });
    }
  }

  const joistAligned = vCuts.filter(c => c.onJoist).length;
  const joistTotal = vCuts.length;
  const totalCuts = vCuts.length + hCuts.length;

  return {
    pieces, vCuts, hCuts,
    numRows, numCols,
    totalPlates: pieces.length,
    totalCuts,
    orientation, isRotated,
    plateL, plateW,
    frameLen, frameSpan,
    joistAligned, joistTotal,
  };
}

/**
 * Generate merged variants for a grid where one or more columns span full frameSpan.
 * For a grid with numRows > 1, this replaces per-row pieces in selected columns
 * with a single full-depth piece, reducing total piece count.
 * Returns array of new grid objects (merged variants).
 */
function generateMergedVariants(grid, plateL, plateW) {
  if (grid.numRows <= 1) return []; // nothing to merge
  const numCols = grid.numCols;
  const variants = [];

  // Get column widths from the grid pieces
  const colWidths = [];
  for (let c = 0; c < numCols; c++) {
    const piece = grid.pieces.find(p => p.col === c);
    if (piece) colWidths.push(piece.w);
  }

  // Generate all non-empty subsets of columns to merge (2^numCols - 1 subsets, minus the empty set)
  const totalSubsets = (1 << numCols) - 1; // skip 0 (no merge)
  for (let mask = 1; mask <= totalSubsets; mask++) {
    const mergedCols = new Set();
    let valid = true;

    for (let c = 0; c < numCols; c++) {
      if (mask & (1 << c)) {
        // Check if merged piece (colWidth × frameSpan) fits on a plate in some rotation
        const cw = colWidths[c];
        const fitsNormal = cw <= plateL + EPS && grid.frameSpan <= plateW + EPS;
        const fitsRotated = grid.frameSpan <= plateL + EPS && cw <= plateW + EPS;
        if (!fitsNormal && !fitsRotated) { valid = false; break; }
        mergedCols.add(c);
      }
    }
    if (!valid || mergedCols.size === 0) continue;

    // Build new pieces array
    const pieces = [];
    let colX = 0;
    let colorIdx = 0;
    for (let c = 0; c < numCols; c++) {
      const cw = colWidths[c];
      if (mergedCols.has(c)) {
        // Single full-depth piece for this column
        pieces.push({
          name: `C${c + 1}`,
          row: -1, col: c,
          fx: colX, fy: 0,
          w: cw, h: grid.frameSpan,
          color: PALETTE[colorIdx % PALETTE.length],
          isFullPlate: Math.abs(cw - plateL) < EPS && Math.abs(grid.frameSpan - plateW) < EPS,
          needsCutW: cw < plateL - EPS,
          needsCutH: grid.frameSpan < plateW - EPS,
        });
        colorIdx++;
      } else {
        // Keep per-row pieces for this column
        for (let r = 0; r < grid.numRows; r++) {
          const rowY = r * grid.plateW;
          const rowH = Math.min(grid.plateW, grid.frameSpan - rowY);
          pieces.push({
            name: `R${r + 1}C${c + 1}`,
            row: r, col: c,
            fx: colX, fy: rowY,
            w: cw, h: rowH,
            color: PALETTE[colorIdx % PALETTE.length],
            isFullPlate: Math.abs(cw - plateL) < EPS && Math.abs(rowH - grid.plateW) < EPS,
            needsCutW: cw < plateL - EPS,
            needsCutH: rowH < grid.plateW - EPS,
          });
          colorIdx++;
        }
      }
      colX += cw;
    }

    // Recalculate cuts
    // Vertical cuts stay the same (between columns)
    const vCuts = [...grid.vCuts];

    // Horizontal cuts: only apply across unmerged columns
    // If ALL columns are merged, no horizontal cuts needed
    const allMerged = mergedCols.size === numCols;
    const hCuts = allMerged ? [] : [...grid.hCuts];

    const totalCuts = vCuts.length + hCuts.length;

    variants.push({
      pieces, vCuts, hCuts,
      numRows: grid.numRows, numCols,
      totalPlates: pieces.length,
      totalCuts,
      orientation: grid.orientation,
      isRotated: grid.isRotated,
      plateL: grid.plateL, plateW: grid.plateW,
      frameLen: grid.frameLen, frameSpan: grid.frameSpan,
      joistAligned: grid.joistAligned, joistTotal: grid.joistTotal,
      mergedCols, // Set of merged column indices
    });
  }

  return variants;
}

// ===== MAIN COMPUTE =====
function computeLayout(s) {
  const joists = [];
  for (let i = 0; i < s.joistCount; i++) {
    joists.push(s.joistSpacing * (i + 1));
  }

  const issues = [];
  const warnings = [];

  if (s.frameW <= 0 || s.frameD <= 0) { issues.push('Frame dimensions must be positive'); }
  if (s.osbL <= 0 || s.osbW <= 0) { issues.push('Plate dimensions must be positive'); }
  if (s.plateCount < 1) { issues.push('Need at least 1 plate'); }
  if (issues.length > 0) {
    return { joists, pieces: [], grid: null, assignment: null, issues, warnings, valid: false, candidates: [] };
  }

  // Generate all candidate grids: 4 orientations × multiple cut positions
  const candidates = [];

  // Horizontal: plates run along frameW, rows stack along frameD
  candidates.push(...generateOptimizedGrids(s.frameW, s.frameD, s.osbL, s.osbW, joists, s.lumberW, 'horizontal', false));
  candidates.push(...generateOptimizedGrids(s.frameW, s.frameD, s.osbW, s.osbL, joists, s.lumberW, 'horizontal (rotated)', true));

  // Vertical: plates run along frameD, rows stack along frameW
  candidates.push(...generateOptimizedGrids(s.frameD, s.frameW, s.osbL, s.osbW, joists, s.lumberW, 'vertical', false));
  candidates.push(...generateOptimizedGrids(s.frameD, s.frameW, s.osbW, s.osbL, joists, s.lumberW, 'vertical (rotated)', true));

  // Also add the uniform-grid candidates as baseline
  candidates.push(generateGrid(s.frameW, s.frameD, s.osbL, s.osbW, joists, s.lumberW, 'horizontal', false));
  candidates.push(generateGrid(s.frameW, s.frameD, s.osbW, s.osbL, joists, s.lumberW, 'horizontal (rotated)', true));
  candidates.push(generateGrid(s.frameD, s.frameW, s.osbL, s.osbW, joists, s.lumberW, 'vertical', false));
  candidates.push(generateGrid(s.frameD, s.frameW, s.osbW, s.osbL, joists, s.lumberW, 'vertical (rotated)', true));

  // Generate merged variants for grids with multiple rows
  const baseCandidateCount = candidates.length;
  for (let i = 0; i < baseCandidateCount; i++) {
    const grid = candidates[i];
    if (grid.numRows > 1) {
      const pL = grid.isRotated ? s.osbW : s.osbL;
      const pW = grid.isRotated ? s.osbL : s.osbW;
      const merged = generateMergedVariants(grid, pL, pW);
      candidates.push(...merged);
    }
  }

  // Try packing for each candidate and score by actual plates used
  const results = candidates.map(grid => {
    const pL = grid.isRotated ? s.osbW : s.osbL;
    const pW = grid.isRotated ? s.osbL : s.osbW;
    const assignment = assignPlatePacking(grid.pieces, pL, pW, s.plateCount);
    return { grid, assignment, packPlateL: pL, packPlateW: pW };
  });

  // Sort: success → fewest plates used → fewest pieces → fewest frame cuts → most joist-aligned
  results.sort((a, b) => {
    const aOk = a.assignment.success ? 0 : 1;
    const bOk = b.assignment.success ? 0 : 1;
    if (aOk !== bOk) return aOk - bOk;
    if (a.assignment.totalPlatesUsed !== b.assignment.totalPlatesUsed)
      return a.assignment.totalPlatesUsed - b.assignment.totalPlatesUsed;
    // Fewest pieces (simplest construction)
    if (a.grid.totalPlates !== b.grid.totalPlates)
      return a.grid.totalPlates - b.grid.totalPlates;
    // Fewest frame cuts
    if (a.grid.totalCuts !== b.grid.totalCuts)
      return a.grid.totalCuts - b.grid.totalCuts;
    // Most joist-aligned among remaining
    const aJoist = a.grid.joistTotal > 0 ? a.grid.joistAligned / a.grid.joistTotal : 1;
    const bJoist = b.grid.joistTotal > 0 ? b.grid.joistAligned / b.grid.joistTotal : 1;
    if (Math.abs(aJoist - bJoist) > 0.01) return bJoist - aJoist;
    return 0;
  });

  const bestResult = results[0];
  const best = bestResult.grid;
  const assignment = bestResult.assignment;
  const packPlateL = bestResult.packPlateL;
  const packPlateW = bestResult.packPlateW;

  if (!assignment.success) {
    issues.push(assignment.feedback);
  }

  // Joist alignment warnings
  for (const cut of best.vCuts) {
    if (!cut.onJoist) {
      warnings.push(`Cut at ${cut.pos.toFixed(1)} cm not on a joist — consider adding support`);
    }
  }

  // Waste calculation
  const totalPlateArea = assignment.totalPlatesUsed * packPlateL * packPlateW;
  const usedArea = best.pieces.reduce((sum, p) => sum + p.w * p.h, 0);
  const wasteArea = totalPlateArea - usedArea;
  const wastePct = totalPlateArea > 0 ? (wasteArea / totalPlateArea * 100) : 0;

  return {
    joists,
    pieces: best.pieces,
    grid: best,
    assignment: assignment.success ? assignment : null,
    issues, warnings,
    valid: issues.length === 0 && assignment.success,
    candidates, results,
    wasteArea, wastePct,
    packPlateL, packPlateW,
  };
}

// ===== DRAWING: FRAME =====
function drawFrame(canvas, s, layout) {
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  ctx.clearRect(0, 0, W, H);

  if (!layout.grid) return;

  const grid = layout.grid;
  const isVertical = grid.orientation.startsWith('vertical');

  // For drawing, we always show the frame as W x D with joists along W
  // In vertical mode, the grid's frameLen is along D and frameSpan is along W
  const pad = 50;
  const sc = Math.min((W - pad * 2) / s.frameW, (H - pad * 2) / s.frameD);
  const offX = (W - s.frameW * sc) / 2;
  const offY = (H - s.frameD * sc) / 2;
  const tx = x => offX + x * sc;
  const ty = y => offY + y * sc;

  // Frame outline
  ctx.strokeStyle = COLORS.frame;
  ctx.lineWidth = 3;
  ctx.strokeRect(tx(0), ty(0), s.frameW * sc, s.frameD * sc);

  // Joists
  ctx.strokeStyle = COLORS.joist;
  ctx.lineWidth = s.lumberW * sc;
  ctx.setLineDash([]);
  for (const j of layout.joists) {
    ctx.beginPath(); ctx.moveTo(tx(j), ty(0)); ctx.lineTo(tx(j), ty(s.frameD)); ctx.stroke();
  }

  // Frame beams
  ctx.lineWidth = s.lumberW * sc;
  ctx.strokeStyle = COLORS.frame;
  [[0, 0, 0, s.frameD], [s.frameW, 0, s.frameW, s.frameD], [0, 0, s.frameW, 0], [0, s.frameD, s.frameW, s.frameD]].forEach(([x1, y1, x2, y2]) => {
    ctx.beginPath(); ctx.moveTo(tx(x1), ty(y1)); ctx.lineTo(tx(x2), ty(y2)); ctx.stroke();
  });

  // Pieces
  for (const p of layout.pieces) {
    // Convert grid coords to frame coords
    let frameX, frameY, frameW_p, frameH_p;
    if (isVertical) {
      // Grid frameLen runs along real frameD, frameSpan runs along real frameW
      frameX = p.fy; frameY = p.fx;
      frameW_p = p.h; frameH_p = p.w;
    } else {
      frameX = p.fx; frameY = p.fy;
      frameW_p = p.w; frameH_p = p.h;
    }

    ctx.globalAlpha = 0.35;
    ctx.fillStyle = p.color;
    ctx.fillRect(tx(frameX), ty(frameY), frameW_p * sc, frameH_p * sc);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.strokeRect(tx(frameX), ty(frameY), frameW_p * sc, frameH_p * sc);

    ctx.fillStyle = '#fff';
    ctx.font = '12px Segoe UI, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.name, tx(frameX + frameW_p / 2), ty(frameY + frameH_p / 2) - 7);
    ctx.font = '10px Segoe UI, sans-serif';
    ctx.fillStyle = '#ccc';
    ctx.fillText(`${frameW_p.toFixed(1)}×${frameH_p.toFixed(1)}`, tx(frameX + frameW_p / 2), ty(frameY + frameH_p / 2) + 7);
  }

  // Cut lines
  ctx.setLineDash([6, 4]);
  ctx.lineWidth = 2;

  // Vertical cuts (between columns)
  for (const cut of grid.vCuts) {
    ctx.strokeStyle = cut.onJoist ? COLORS.cutOnJoist : COLORS.cutOffJoist;
    if (isVertical) {
      // In vertical mode, vCuts are along frameD (real Y axis)
      ctx.beginPath(); ctx.moveTo(tx(0), ty(cut.pos)); ctx.lineTo(tx(s.frameW), ty(cut.pos)); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.moveTo(tx(cut.pos), ty(0)); ctx.lineTo(tx(cut.pos), ty(s.frameD)); ctx.stroke();
    }
  }

  // Horizontal cuts (between rows) — skip merged columns
  ctx.strokeStyle = '#6366f1';
  for (const cut of grid.hCuts) {
    if (grid.mergedCols && grid.mergedCols.size > 0) {
      // Draw partial lines only across unmerged columns
      for (const p of grid.pieces) {
        if (p.row === -1) continue; // merged piece, skip
        if (p.row !== 0) continue; // only need first row to get column extents
        const c = p.col;
        if (grid.mergedCols.has(c)) continue; // skip merged columns
        // Draw hCut segment across this column
        if (isVertical) {
          ctx.beginPath(); ctx.moveTo(tx(cut.pos), ty(p.fx)); ctx.lineTo(tx(cut.pos), ty(p.fx + p.w)); ctx.stroke();
        } else {
          ctx.beginPath(); ctx.moveTo(tx(p.fx), ty(cut.pos)); ctx.lineTo(tx(p.fx + p.w), ty(cut.pos)); ctx.stroke();
        }
      }
    } else {
      // No merged columns — full-width line
      if (isVertical) {
        ctx.beginPath(); ctx.moveTo(tx(cut.pos), ty(0)); ctx.lineTo(tx(cut.pos), ty(s.frameD)); ctx.stroke();
      } else {
        ctx.beginPath(); ctx.moveTo(tx(0), ty(cut.pos)); ctx.lineTo(tx(s.frameW), ty(cut.pos)); ctx.stroke();
      }
    }
  }
  ctx.setLineDash([]);

  // Joist labels
  ctx.font = '10px Segoe UI, sans-serif';
  ctx.fillStyle = '#999';
  ctx.textAlign = 'center';
  for (const j of layout.joists) ctx.fillText(`${j}`, tx(j), ty(-0.06 * s.frameD));

  // Dimension labels
  ctx.fillStyle = '#e74c3c';
  ctx.font = '11px Segoe UI, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`${s.frameW} cm`, tx(s.frameW / 2), ty(-0.14 * s.frameD));
  ctx.save();
  ctx.translate(tx(-0.08 * s.frameW), ty(s.frameD / 2));
  ctx.rotate(-Math.PI / 2);
  ctx.fillStyle = '#2ecc71';
  ctx.fillText(`${s.frameD} cm`, 0, 0);
  ctx.restore();

  // Orientation label
  ctx.fillStyle = '#666';
  ctx.font = '10px Segoe UI, sans-serif';
  ctx.textAlign = 'center';
  const orientLabel = isVertical ? 'Plates run front→back' : 'Plates run left→right';
  ctx.fillText(orientLabel, tx(s.frameW / 2), ty(s.frameD + 0.06 * s.frameD));

  if (layout.valid) {
    ctx.strokeStyle = COLORS.validBorder;
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.strokeRect(tx(-2), ty(-2), (s.frameW + 4) * sc, (s.frameD + 4) * sc);
  }
}

// ===== DRAWING: PLATE =====
function drawPlate(canvas, plateLayout, plateL, plateW) {
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;
  ctx.clearRect(0, 0, W, H);

  if (!plateLayout || plateLayout.length === 0) {
    ctx.fillStyle = '#555';
    ctx.font = '14px Segoe UI, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('No pieces assigned', W / 2, H / 2);
    return;
  }

  const pad = 30;
  const sc = Math.min((W - pad * 2) / plateL, (H - pad * 2) / plateW);
  const offX = (W - plateL * sc) / 2;
  const offY = (H - plateW * sc) / 2;
  const tx = x => offX + x * sc;
  const ty = y => offY + y * sc;

  // Plate outline
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 2;
  ctx.strokeRect(tx(0), ty(0), plateL * sc, plateW * sc);

  // Pieces
  for (const item of plateLayout) {
    const p = item.piece;
    const pw = item.pw || p.w;  // placed width (may be rotated)
    const ph = item.ph || p.h;  // placed height
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = p.color;
    ctx.fillRect(tx(item.x), ty(item.y), pw * sc, ph * sc);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.strokeRect(tx(item.x), ty(item.y), pw * sc, ph * sc);

    ctx.fillStyle = '#fff';
    ctx.font = '11px Segoe UI, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const cx = tx(item.x + pw / 2);
    const cy = ty(item.y + ph / 2);
    ctx.fillText(p.name, cx, cy - 6);
    ctx.font = '9px Segoe UI, sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.fillText(`${pw.toFixed(1)}×${ph.toFixed(1)}`, cx, cy + 7);
  }

  // Cut lines
  ctx.setLineDash([6, 3]);
  ctx.lineWidth = 1.5;
  const xCuts = new Set(), yCuts = new Set();
  for (const item of plateLayout) {
    const pw = item.pw || item.piece.w;
    const ph = item.ph || item.piece.h;
    if (item.x > EPS) xCuts.add(item.x);
    if (item.x + pw < plateL - EPS) xCuts.add(item.x + pw);
    if (item.y > EPS) yCuts.add(item.y);
    if (item.y + ph < plateW - EPS) yCuts.add(item.y + ph);
  }
  ctx.strokeStyle = '#ef4444';
  for (const cx of xCuts) {
    ctx.beginPath(); ctx.moveTo(tx(cx), ty(0)); ctx.lineTo(tx(cx), ty(plateW)); ctx.stroke();
  }
  ctx.strokeStyle = '#f59e0b';
  for (const cy of yCuts) {
    ctx.beginPath(); ctx.moveTo(tx(0), ty(cy)); ctx.lineTo(tx(plateL), ty(cy)); ctx.stroke();
  }
  ctx.setLineDash([]);

  // Plate size label
  ctx.fillStyle = '#555';
  ctx.font = '10px Segoe UI, sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText(`${plateL}×${plateW} cm`, tx(plateL), ty(plateW) + 20);
}

// ===== DYNAMIC PLATE CANVASES =====
function ensurePlateCanvases(count) {
  const container = document.getElementById('platesContainer');
  // Always rebuild — simpler and avoids stale DOM issues
  container.innerHTML = '';
  for (let i = 0; i < count; i++) {
    const section = document.createElement('div');
    section.className = 'diagram-section plate-section';
    section.innerHTML = `<h2 id="plateTitle${i}">Plate ${i + 1}</h2><canvas id="plateCanvas${i}" height="180"></canvas>`;
    container.appendChild(section);
  }
}

// ===== UI =====
function updatePiecesTable(layout) {
  const body = document.getElementById('piecesBody');
  if (!layout.grid) { body.innerHTML = ''; return; }

  const pieces = layout.pieces;
  const assignment = layout.assignment;

  body.innerHTML = pieces.map(p => {
    let plateNum = '—', ok = false;
    if (assignment) {
      for (let pi = 0; pi < assignment.plates.length; pi++) {
        if (assignment.plates[pi].pieces.some(pp => pp.name === p.name)) {
          plateNum = `Plate ${pi + 1}`;
          ok = true;
          break;
        }
      }
    }
    const isVertical = layout.grid.orientation.startsWith('vertical');
    const frameX = isVertical ? p.fy : p.fx;
    const frameY = isVertical ? p.fx : p.fy;
    const posLabel = `(${frameX.toFixed(0)}, ${frameY.toFixed(0)})`;
    const dims = isVertical ? `${p.h.toFixed(1)} × ${p.w.toFixed(1)}` : `${p.w.toFixed(1)} × ${p.h.toFixed(1)}`;

    return `<tr class="${ok ? 'valid-row' : 'invalid-row'}">
      <td><strong style="color:${p.color}">${p.name}</strong></td>
      <td>${dims} cm</td>
      <td>${plateNum}</td>
      <td>${posLabel}</td>
      <td>${ok ? '&#10003;' : '&#10007;'}</td>
    </tr>`;
  }).join('');

  document.getElementById('wasteInfo').innerHTML = layout.valid
    ? `Waste: <span>${layout.wasteArea.toFixed(0)} cm<sup>2</sup> (${layout.wastePct.toFixed(1)}%)</span> &nbsp;|&nbsp; ${layout.assignment.totalPlatesUsed} plate${layout.assignment.totalPlatesUsed > 1 ? 's' : ''} used`
    : '';
}

function updateValidation(layout) {
  const banner = document.getElementById('validationBanner');
  const text = document.getElementById('validationText');
  const list = document.getElementById('issuesList');

  if (layout.valid) {
    const grid = layout.grid;
    banner.className = 'validation-banner valid';
    text.innerHTML = `&#10003; Valid — ${grid.totalPlates} pieces on ${layout.assignment.totalPlatesUsed} plate${layout.assignment.totalPlatesUsed > 1 ? 's' : ''}`;

    if (layout.warnings.length > 0) {
      list.style.display = 'block';
      list.innerHTML = layout.warnings.map(w => `<li class="warning">&#9888; ${w}</li>`).join('');
    } else {
      list.style.display = 'none';
    }
  } else {
    banner.className = 'validation-banner invalid';
    text.innerHTML = `&#10007; ${layout.issues.length} issue${layout.issues.length > 1 ? 's' : ''}`;
    list.style.display = 'block';
    const allItems = [
      ...layout.issues.map(i => `<li>${i}</li>`),
      ...layout.warnings.map(w => `<li class="warning">&#9888; ${w}</li>`),
    ];
    list.innerHTML = allItems.join('');
  }
}

function updateSolverInfo(layout) {
  const group = document.getElementById('solverInfoGroup');
  const info = document.getElementById('solverInfo');

  if (!layout.grid) { group.style.display = 'none'; return; }
  group.style.display = '';

  const grid = layout.grid;
  const orientTag = `<span class="orientation-tag">${grid.orientation}</span>`;

  // Grid size description — include merge info if applicable
  let gridDesc;
  if (grid.mergedCols && grid.mergedCols.size > 0) {
    const mergedNames = [...grid.mergedCols].map(c => `C${c + 1}`).join(', ');
    gridDesc = `${grid.numRows} × ${grid.numCols} grid, ${mergedNames} merged → <strong>${grid.totalPlates} pieces</strong>`;
  } else {
    const gridSize = `${grid.numRows} row${grid.numRows > 1 ? 's' : ''} × ${grid.numCols} col${grid.numCols > 1 ? 's' : ''}`;
    gridDesc = `<strong>${gridSize}</strong> = ${grid.totalPlates} pieces`;
  }

  const joistInfo = grid.joistTotal > 0
    ? `Joist-aligned cuts: <strong>${grid.joistAligned}/${grid.joistTotal}</strong>`
    : 'No vertical cuts needed';

  // Column widths info
  const colWidths = [];
  for (let c = 0; c < grid.numCols; c++) {
    const piece = grid.pieces.find(p => p.col === c);
    if (piece) colWidths.push(piece.w.toFixed(1));
  }
  const colInfo = grid.numCols > 1 ? `Column widths: ${colWidths.join(' + ')} cm` : '';

  // Summarize candidates: group by orientation, show best per orientation
  const totalCandidates = layout.candidates.length;
  const successCount = layout.results ? layout.results.filter(r => r.assignment.success).length : '?';

  const cutsInfo = grid.totalCuts === 0 ? 'No cuts needed'
    : `Frame cuts: <strong>${grid.totalCuts}</strong> (${grid.vCuts.length} vertical, ${grid.hCuts.length} horizontal)`;

  info.innerHTML = `
    Orientation: ${orientTag}<br>
    Grid: ${gridDesc}<br>
    ${colInfo ? colInfo + '<br>' : ''}
    ${cutsInfo}<br>
    ${joistInfo}<br>
    <span style="color:#555;">Tried ${totalCandidates} layouts, ${successCount} valid</span>
  `;
}

function update() {
  const s = getInputs();
  if (Object.values(s).some(v => isNaN(v))) return;
  const layout = computeLayout(s);

  drawFrame(document.getElementById('frameCanvas'), s, layout);

  // Dynamic plate canvases
  if (layout.assignment) {
    const numPlates = layout.assignment.totalPlatesUsed;
    ensurePlateCanvases(numPlates);
    requestAnimationFrame(() => {
      for (let i = 0; i < numPlates; i++) {
        const plate = layout.assignment.plates[i];
        const titleEl = document.getElementById(`plateTitle${i}`);
        const canvasEl = document.getElementById(`plateCanvas${i}`);
        if (titleEl) titleEl.textContent = `Plate ${i + 1} — ${plate.pieces.map(p => p.name).join(' + ')}`;
        if (canvasEl) drawPlate(canvasEl, plate.layout, layout.packPlateL, layout.packPlateW);
      }
    });
  } else {
    ensurePlateCanvases(0);
  }

  updatePiecesTable(layout);
  updateValidation(layout);
  updateSolverInfo(layout);
}

document.querySelectorAll('input, select').forEach(el => {
  el.addEventListener('input', update);
  el.addEventListener('change', update);
});
window.addEventListener('resize', update);
update();
</script>
</body>
</html>
